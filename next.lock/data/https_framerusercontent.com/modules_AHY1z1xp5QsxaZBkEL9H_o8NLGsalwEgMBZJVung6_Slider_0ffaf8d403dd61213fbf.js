import * as React from "react"; import { addPropertyControls , ControlType , useTransform , RenderTarget , motion , animate , transform } from "framer"; import { useRef , useState , useCallback , useMemo } from "react"; import { isMotionValue , useUniqueClassName , useOnChange , containerStyles , useAutoMotionValue } from "https://framer.com/m/framer/default-utils.js"; import { throttle } from "https://framer.com/m/framer/lodash.js"; var KnobOptions; (function (KnobOptions) { KnobOptions["Hide"] = "Hide"; KnobOptions["Hover"] = "Hover"; KnobOptions["Show"] = "Show"; })(KnobOptions || (KnobOptions = {})); export function Slider (props) { const { value: valueProp, trackHeight, fillColor, focusColor, min, max, onChange, onChangeLive, onMax, onMin, trackColor, trackRadius, knobSize, knobColor, constrainKnob, shadow, shouldAnimateChange, transition, overdrag, knobSetting, style } = props; const [hovered,setHovered] = useState(false); const [focused,setFocused] = useState(false); const onCanvas = RenderTarget.current() === RenderTarget.canvas; const shouldAnimate = shouldAnimateChange && !onCanvas; const isConstrained = constrainKnob && knobSetting === KnobOptions.Show; const showKnob = knobSetting !== KnobOptions.Hide; const input = useRef(); const knobPadding = 8; const updateValue = useCallback((newVal, target) => { throttledInputUpdate(newVal); if (onChange) { onChange(newVal) }; if (shouldAnimate) { animate(target, newVal, transition) } else { requestAnimationFrame(() => { return target.set(newVal); }) }; }, [transition, shouldAnimate]); const value = useAutoMotionValue(valueProp, {onChange: updateValue, transform: (value) => { return transform(value, [0, 100], [min, max]); }}); const knobX = useTransform(value, [min, max], ["0%", "100%"]); const normalizedValue = useTransform(value, [min, max], [0, 1]); const className = useUniqueClassName("slider", []); const throttledInputUpdate = useCallback(throttle((val) => { if ((input.current)?.value) { input.current.value = val }; }, 100), [input]); useOnChange(value, (val) => { if (isMotionValue(valueProp)) { throttledInputUpdate(val) }; if (onMax && val >= max) { onMax() }; if (onMin && val <= min) { onMin() }; if (onChangeLive) { onChangeLive(val) }; }); const handleInputChange = (e) => { updateValue(parseFloat(e.target.value), value); }; const handleMouseDown = (e) => { if (parseFloat(e.target.value) !== 0) { updateValue(parseFloat(e.target.value), value) }; }; const handleMouseUp = () => { }; const totalKnobWidth = showKnob ? knobSize + knobPadding : knobPadding; const knobStyles = useMemo(() => { return `\n            height: ${Math.max(knobSize + knobPadding, trackHeight)}px;\n            width: ${totalKnobWidth}px;\n            border-radius: 0;\n            -webkit-appearance: none;\n            background: none;\n        `; }, [knobSize]); return React.createElement("div", {className, onMouseEnter: () => { return setHovered(true); }, onMouseLeave: () => { return setHovered(false); }, style: {...containerStyles, ...style, justifyContent: "flex-start", border: `0px solid ${focusColor}`}}, React.createElement("input", {ref: input, style: {flexShrink: 0, height: "100%", opacity: 0, WebkitTapHighlightColor: "rgba(0, 0, 0, 0)", ...!isConstrained && {width: `calc(100% + ${totalKnobWidth}px)`, marginLeft: -totalKnobWidth / 2}}, onFocus: () => { return setFocused(true); }, onBlur: () => { return setFocused(false); }, type: "range", min, max, defaultValue: -1, step: "any", onChange: handleInputChange, onMouseDown: handleMouseDown, onMouseUp: handleMouseUp}), React.createElement("div", {style: {background: trackColor, position: "absolute", top: `calc(50% - ${trackHeight / 2}px)`, borderRadius: trackRadius, height: trackHeight, width: "100%", transformOrigin: "left", pointerEvents: "none", overflow: "hidden"}}, React.createElement(motion.div, {style: {height: trackHeight, width: "100%", background: fillColor, scaleX: normalizedValue, position: "absolute", top: `calc(50% - ${trackHeight / 2}px)`, transformOrigin: "left", pointerEvents: "none"}})), React.createElement(motion.div, {style: {x: knobX, position: "absolute", display: "flex", top: `calc(50% - ${knobSize / 2}px)`, pointerEvents: "none", ...isConstrained ? {width: `calc(100% - ${knobSize}px`, left: 0} : {width: `100%`, left: -knobSize / 2}}}, React.createElement(motion.div, {initial: false, animate: {scale: hovered && knobSetting === KnobOptions.Hover || knobSetting === KnobOptions.Show ? 1 : 0}, transition: {type: "spring", stiffness: 900, damping: 40}, style: {transformOrigin: "50% 50%", width: knobSize, height: knobSize, borderRadius: "50%", background: knobColor, pointerEvents: "none", boxShadow: `0px 1px 2px 0px ${shadow}, \n                                0px 2px 4px 0px ${shadow}, \n                                0px 4px 8px 0px ${shadow}`}})), React.createElement("style", null, `\n                    .${className} input[type=range] {\n                        -webkit-appearance: none;\n                        width: 100%; \n                        height: 100%;\n                        background: transparent;\n                    }\n\n                    .${className} input[type=range]:focus {\n                        outline: none;\n                    }\n\n                    .${className} input[type=range]::-ms-track {\n                        width: 100%;\n                        cursor: pointer;\n                        background: transparent; \n                        border-color: transparent;\n                        color: transparent;\n                    }\n\n                    .${className} input[type=range]::-webkit-slider-thumb {\n                        ${knobStyles}\n                    }\n\n                    .${className} input[type=range]::-moz-range-thumb {\n                        ${knobStyles}\n                    }\n\n                    .${className} input[type=range]::-ms-thumb {\n                        ${knobStyles}\n                    }\n                `)); }; Slider.displayName = "Slider"; Slider.defaultProps = {height: 20, width: 200, trackHeight: 4, fillColor: "#09F", trackColor: "#DDD", knobColor: "#FFF", focusColor: "rgba(0, 153, 255,0)", shadow: "rgba(0,0,0,0.1)", knobSize: 20, overdrag: true, min: 0, max: 100, value: 50, trackRadius: 5, knobSetting: "Show", constrainKnob: false, transition: {type: "spring", delay: 0, stiffness: 750, damping: 50}, shouldAnimateChange: true}; addPropertyControls(Slider, {fillColor: {title: "Tint", type: ControlType.Color}, trackColor: {title: "Track", type: ControlType.Color}, knobColor: {title: "Knob", type: ControlType.Color}, shadow: {type: ControlType.Color, title: "Shadow"}, shouldAnimateChange: {type: ControlType.Boolean, title: "Changes", enabledTitle: "Animate", disabledTitle: "Instant"}, transition: {type: ControlType.Transition, defaultValue: Slider.defaultProps.transition}, knobSetting: {type: ControlType.Enum, displaySegmentedControl: true, title: "Knob", options: ["Hide", "Hover", "Show"]}, constrainKnob: {type: ControlType.Boolean, title: "Constrain", enabledTitle: "Yes", disabledTitle: "No", hidden: ({ knobSetting }) => { return knobSetting !== KnobOptions.Show; }}, knobSize: {type: ControlType.Number, title: "Knob", min: 10, max: 100, hidden: ({ knobSetting }) => { return knobSetting === KnobOptions.Hide; }}, value: {type: ControlType.Number, title: "Value", min: 0, max: 100, unit: "%"}, trackHeight: {title: "Height", type: ControlType.Number, min: 0}, min: {title: "Min", type: ControlType.Number, displayStepper: true}, trackRadius: {type: ControlType.Number, displayStepper: true, min: 0, max: 200, title: "Radius"}, max: {title: "Max", type: ControlType.Number, displayStepper: true}, onChange: {type: ControlType.EventHandler}, onMax: {type: ControlType.EventHandler}, onMin: {type: ControlType.EventHandler}}); export const __FramerMetadata__ = {exports: {Slider: {type: "reactComponent", slots: [], annotations: {framerIntrinsicHeight: "20", framerIntrinsicWidth: "200"}}}}; 